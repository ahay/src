\title{IWAVE Structure and Basic Use Cases}
\author{William. W. Symes \thanks{The Rice Inversion Project,
Department of Computational and Applied Mathematics, Rice University,
Houston TX 77251-1892 USA, email {\tt symes@caam.rice.edu}.}}

\maketitle
\parskip 12pt


\begin{abstract}
  The IWAVE control structure facilitates construction of wave
  simulators with flexible specification of input and output. This
  document describes synthesis of seismograms and wavefield movies
  from initial data and from single and multiple sources (right-hand
  sides), and linearized (``Born'') and linearized adjoint
  (reverse time migration) modeling. The choice of physical model and
  simulation method - constant density acoustics with Dirichlet
  boundary conditions and $(2,2k)$ finite difference schemes - is the
  simplest possible, but the framework accommodates any regularly
  gridded stencil-based discretization of arbitrary wave physics in the same way.
\end{abstract}

\inputdir{project}

\section{Introduction}
IWAVE combines minimal physics- and scheme-specific code with
a common base of memory allocation, SPMD communication and other forms
of parallelism, i/o, and
job control code to produce complete wave modeling applications. This
paper explains what code must be written to implement a wave modeling
application in IWAVE, and how IWAVE makes various modeling options
available via a set of examples. It ends with a discussion of various
other extensions and capabilities, implemented or planned, including
various forms of inversion.

The next section describes the general organization of the IWAVE core
code and the additional code that must be added to form an
application. Following this generic structural description, I explain
how to implement it in the case of the simplest useful example,
constant density acoustics.

Some design aspects of IWAVE arise from the intended use cases not
discussed here: parallel processing of shots, subdomains, and loops,
and interface with an object oriented optimization package, the Rice
Vector Library, to facilitate inversion applications. These use cases
and their design implications will form the subjects of other reports.

\section{Structures and Interfaces}
Three components and their relations define a time-stepping simulator
based on regular gridding and stencil field updates:
\begin{itemize}
\item a collection of (discrete) dynamic and static (coefficient) fields;
\item model-specific functions implementing time step stencils, 
  determining space and time grids and stencil shape, and
  sanity-checking coefficient fields;
\item a list of i/o procedures to populate the fields at initial and
  intermediate times, and to extract results at final and intermediate
  times.
\end{itemize}
Definitions and interfaces for these three components form the core of
IWAVE. The critical functions and data structures are static members of the {\tt IWaveInfo} class;
definining them completely defines the application. Declarations
appear in \\{\tt iwave/core/include/iwaveinfo.hh}, which should be
consulted for function signatures etc. Applications must supply
definitions, each unique (as is requlred for static global data), as
described in the final paragraphs of this section.

\subsection{Fields}
The top level data structure characterizing an application implemented
in IWAVE is a list of field keywords and other attributes. Each field
gets a keyword, acting as a mnemonic index for internal and external
reference. Fields are dynamic or static, and may be primal or dual in
each coordinate axis: ``dual'' here refers to the grid, so dual fields
represent values assigned to edges, faces, or volumes, rather than
grid vertices (nodes). IWAVE encodes these boolean attributes as 0's
or 1's. Finally, a bit of information about the scheme intrudes: each
dynamic field is updated in one of the (sub)steps of a (possibly)
multistep method, and for that substep, and that substep only, needs
ghost cell data exchanged.

The {\tt FIELD} struct containing this information is organized in the
order 
\begin{itemize}
\item (string) keyword;
\item (int) dynamic flag;
\item (int) substep number;
\item (int array) duality flag for each axis.
\end{itemize}
For instance, a $(z,x)$ stress component field for a staggered grid elastic
finite difference method is a dynamic fielld, representing a grid
sampled centered in the $(z,x)$ faces of the grid cells, and 
updated in second substep of each time step \cite{moczoetal:06}. The
{\tt FIELD} struct
\begin{verbatim}
{"szx", 1, 1, {1, 1, 0}}
\end{verbatim}
captures this information (here coordinate order is $(z,x,y)$).. Note that the only arbitrary
choice here is the keyword string. The choice of keyword for each field must be
consistent throughout the code.

The distinction between static and dynamic fields is more than a
convenience. Static fields, representing the coefficients of the model
differential equations, must exist in the simulation environment prior
to simulation, in some form of persistent store. Simulation input and output
fields, defined below, must also exist as persistent store prior to
simulation. The current
implementation of IWAVE presumes that ``persistent store'' is a
synonym for ``disk file'', however the logic is simply that the data
for these fields should exist outside of the simulation scope. Future
versions of IWAVE may accommodate distributed data as persistent
store, for instance. Dynamic fields exist only within the scope of the
simulation: IWAVE creates and destroys them in the course of a run.

By convention, the first field listed in the application {\tt FIELD}
array is the source of the primary simulation grid, to which all other
grids are referenced. Since this
information will need to enter the compuation via i/o, this first
field should be static (i.e. a coefficient), which will exist in the
simulation environment prior to execution of the application.

The static array {\tt iwave\_fields} data member of the {\tt
  IWaveInfo} class lists the static
and dynamic fields of an IWAVE
application and their top-level attributes using the {\tt FIELD} struct
explained above. Being static, {\tt iwave\_fields} must be
initialized once, and only once, somewhere in global namespace. That
is, the application author must supply a definition
\begin{verbatim}
iwave_fields = { ... };
\end{verbatim}
somewhere - the preferred location for this definition is in the
model definition header file containing the other required definition to
be reviewed below. This model definition file should be included {\em
  only} in main program source files, as its static declarations must
appear only once in program text.

\subsection{Field allocation}
IWAVE stores all fields as {\em
  rarrays} (or {\tt RARR}s). {\tt RARR} is an intelligent array type
that defines gridpoints by reference to global coordinates in ${\bf
  Z}^d$ for $d$-dimensional simulations, provides both one- and
multi-dimensional access to array data, and includes many utiliities
for data manipulation. The time step function implementing the dynamic
field updates will be written in terms of {\tt RARR} utilities and
data members. The {\tt RARRs} corresponding to the application's
fields together form an {\rm rdomain} ({\tt RDOM}), which is simply an
array of {\tt RARR}, indexed in the order that they appear in the {\tt
  iwave\_fields} array.

Derivatives (and adjoint derivatives) of the simulation map involve
multiple copies of the basic application fields: the first derivative
needs two copies, a set of reference fields and a corresponding set of
perturbation fields. Since the $k$th derivative is the derivative of
the $k-1$st derivative, the $k$th derivative
requires $2^k$ sets of fields in its definition. The {\tt IWaveTree}
data structure of order $k$ is a vector of $2^k$ {\tt RDOM}s suitable
for defining the $k$th derivative; the first $2^{k-1}$ {\tt RDOM}s
comprise the reference {\tt IWaveTree}, the second form the
perturbation. 

\subsection{Functions}
The implementation of an IWAVE application depends on a half-dozen
functions, which the application author must supply. The most obvious
of these is the time step, or dynamic field update, function, and it
is described here. All six essential functions are documented in 
\begin{verbatim}
RSFSRC/trip/iwave/core/include/iwinfo.hh
\end{verbatim}

The time step interface accommodates (in principle) the update
functions for all orders of derivative, and adjoint (reverse mode) as
well as forward time stepping. Its signature is encapsulated in a {\tt
  typedef}:
\begin{verbatim}
typedef void (*FD_TIMESTEP)(std::vector<RDOM *> dom, 
                            bool fwd, 
                            int iv, 
                            void* fdpars);
\end{verbatim}
The first argument is the {\tt RDOM} array extracted from an {\tt
  IWaveTree}. The order of derivative to be computed is the base 2 log
of {\tt dom.size()}. The implementation should take the form of a case
list, one major case for each order of derivative implemented. Each
case (except the simulation itself, or order 0) should be divided into
two subcases, one each for forward and adjoint modes, switched by the
second {\tt bool} argument {\tt fwd}. Each subcase is further divided
into sub-sub-cases according to the {\em substep index} {\tt iv}. This
third refinement permits implementation of multistep methods in this
framework. To take a prominent example, staggered grid methods for
elastodynamics, in their basic form, use leapfrog time stepping, 
a two-step methods: velocity fields are updated from stress fields
in the first substep, stress fields from velocity fields in the
second. This subdivision of time steps in this fashion allows for the
simplest coding and reduces the amount of data in ghost cell exchange
for domain decomposition, an advantage for low-latency systems. The
final {\tt void *} pointer is the usual dodge for faking private class
data members in ``object oriented C'': the opaque object passed by
address should be of a type defined for the given application and
encapsulating all information needed to compute the time step, such as
Courant numbers, auxiliary damping arrays for absorbing layers, and so
on. One of the other five functions initializes this object.

\section{I/O}
The {\tt FIELD} array member of the {\tt IWaveInfo} class defines the
physical fields of a modeling application. The function data members
describe the memory allocation and updating of the arrays representing
these fields. It remains to describe initialization and finalization,
that is, how external data is read to and
written from these arrays.

The basic principle of IWAVE i/o is that {\em the structure of a data item
  determines the manner in which it is read/written}. Absent
self-describing i/o formats, this principle implies that the
relevant part of the code implements a case list. Persistent data is
presumed to exist in disk files, or in any case be identified by
single strings. Accordingly the case switch is the {\em filename suffix}. At
this writing, two file data structures are realized: SEGY minus reel
header, or Seismic Unix (SU) format, suffix {\tt su}, and Regularly
Sampled Function format, suffix {\tt rsf}. [Other file or network data
structures may be added to IWAVE later.]

Since the details of i/o are implicit in the choice of data structure,
it remains only to connect external data units with the data arrays
with which they communicate. Since the data arrays are indexed by
keyword, and since several external data objects may communicate with
the same data array, it follows that a keyword must be introduced to
stand as a proxy for
each external data object in the program text. At runtime, the keyword
appears as an index into an associative array describing program
inputs and ouputs; the value associated to each key is a path. 

Accordingly, the final data member of the
{\tt IWaveInfo} class is the {\tt IOKEY} array {\tt
  iwave\_iokeys}. {\tt IOKEY} is a typedef for a struct consisting of
\begin{itemize}
\item an external data item keyword
\item a field index
\item a flag to indicate input (1) or output (0)
\item an activity flag, which is key to defining the RVL Operator
  interface (see discussion below) - active arrays (1) define
  components of the operator domain (input) or range (output), whereas
  non-active arrays (0) represent auxiliary inputs/outputs.
\end{itemize}
For example, an input to the pressure Cauchy data for
pressure-velocity acoustics, regarded as auxiliary data, might be
represented by the {\tt IOKEY}
\begin{verbatim}
{"init_p", 1, 1, 0}
\end{verbatim}
(assuming that the pressure array has index 1) whereas the output of the same array data, regarded as defining part
of the range of the simulation operator, might correspond to
\begin{verbatim}
{"movie_p",1, 0, 1}
\end{verbatim}
Note that any sampling in space and/or time may be represented in this
way, and is determined at the time of interaction with the external
data unit. Some details of file structure controlling IWAVE i/o are
discussed in later in this paper.

The indirection afforded by the external data unit keyword allows the
the same IWAVE-based command to be used for many different
combinations of inputs and outputs. Parameter
pairs {\tt keyword = filename } passed from a driver serve to connect
specific disk files or other data repositories to external data
keywords, hence to read/write operations.

The IOKEYS array defines i/o info for the basic simulation. Keywords
for perturbation fields, used in derivatives and adjoint derivatives, are generated
automatically. For example, if the keyword for density is {\tt rho},
then the keyword for the first perturbation density (input to the
first derivative) is {\tt rho\_d1}, The adjoint output density
is {\tt rho\_b1}. The choices of suffix correspond to
those generated by the {\em Tapenade} automatic differentiation
package \cite{TapenadeRef13}. These keywords would be used in as parameter keys in pairs
passed to driver routines, for example, {\tt rho\_d1 = my\_density\_pert.rsf}.

\subsection{IWaveInfo}
Definition of an IWAVE application amounts to initialization, in
global namespace of the static public data members of the {\tt
  IWaveInfo} class:
\begin{verbatim}
  static FIELD iwave_fields[]; 
  static IOKEY iwave_iokeys[];
  static FD_MODELINIT minit;
  static FD_MODELDEST mdest;
  static FD_TIMESTEP timestep;
  static FD_TIMEGRID timegrid;
  static FD_STENCIL createstencil;
  static FD_CHECK check;
\end{verbatim}
These initializations must occur precisely once for each application. The recommended
procedure is to assign all members except {\tt iwave\_iokeys} in
a {\em model definition}  header file, which includes both the declarations of the
static data types (via {\tt \#include "iwinfo.hh"}) and of the
function data members (via {\tt \#include} of the main model header
file).  The {\tt iwave\_iokeys} array, on the other hand, should be
assigned at the top of each command file, after {\tt \#include} of the
model definition file. 

This organization allows the model application library (object files
defining various functions) to be linked
without alteration to a variety of
drivers (main program files) implementing different input/output 
choices. I have identified two main use cases:
\begin{itemize}
\item standalone command: a standalone driver such as {\tt acd} (next
  section) must have keys provided for all inputs and outputs
  contemplated. I/O keys for which key=value pairs don't appear
  amongst the parameters passed to the application at runtime are simply
  ignored. So this command can be used for all possibilities covered
  by the chosen I/O keys without any alteration. See the next section
  for illustration.
\item RVL Operator interface, for use in inversion applications: the constructor builds its domain and
  range spaces using the supplied I/O keys - this is the reason for
  the ``active'' flag.  I/O keys flagged as active define components
  of domain and range (product) spaces, with geomtry metadata taken
  from the files which the keys point to via the parameter list. Data
  sources corresponding to these keys must be present in the
  environment and correspond to parameter values. This use case will
  be described in more detail in another report.
\end{itemize}

A negative consequence of IWAVE's reliance on static global
definitions is that only one IWAVE modeling application can be active
in a given process. This disadvantage is offset by two considerations:
(1) in the use cases for which IWAVE was designed, only one modeling
application per process is required; (2) the creation of a new IWAVE
application is as simple as one can imagine, requiring only the
definition of a couple of arrays and half-a-dozen functions with
specified signatures, and their assignment to static data of {\tt
  IWaveInfo}. If in the future interesting use cases arise in which
truly distinct modeling packages must be combined in the same process,
then simple modificiations of the IWAVE overall structure will answer,
with slightly increased burden on the programmer.

\section{Case: Constant-density Acoustics}
A simple example illustrating the framework described above is the
IWAVE implementation of
the constant-density acoustic wave equation with Dirichlet
(pressure-free) boundary conditions, connecting the acoustic
potential field $u({\bf x},t)$ and a right-hand side $f({\bf x},t)$
representing a source of mechanical energy, defined in a spatial
domain $\Omega$ over a suitable time interval,
\[
\frac{\partial^2 u}{\partial t^2} - c^2 \nabla^2 u = f,
\]
\[
u(\bx,0) = u_0(\bx),\,\,\frac{\partial u}{\partial t}(\bx,0) =
v(\bx)\,\, \bx \in \Omega,
\]
\[
u(\bx,t) = 0, \,\bx \in \partial \Omega.
\]
The examples to be discussed use the centered
difference approximation \cite[]{kel76}
\[
u^{n+1} = 2 u^{n} - u^{n-1} + \Delta t^2 c^2 Lu^n + \Delta t^2 f^n
\]
in which $L$ is a regular grid difference approximation to the Laplacian, and $u^n$
represents the array of acoustic potential samples for time $n\Delta t$. The choice of $L$
used below is a sum of centered coordinate second difference
operators of order $2k$, $k=1, 2, 4,...$ resulting in a scheme of
formal order $2$ in time and $2k$ in space. Lax-Wendroff extension to
higher order time approximation fits this pattern also.

Since each array element in $u^{n-1}$ appears exactly once in a loop
through the array, it is possible to store only the two arrays for
time indices $n-1$ and $n$, represented by {\tt RARR}s {\tt up} and
{\tt uc} respectively, and store $c^2$ in the {\tt RARR} {\tt csq}.
The the three-level scheme above becomes
\begin{verbatim}
up = 2 * uc - up + dt2 * csq .* L uc + dt2 * f^n
[swap up, uc]
\end{verbatim}
With the type of discrete finite difference Laplacian described above,
the grids for {\tt uc}, {\tt up}, and {\tt csq} are all primal, and
commensurable. Since {\tt csq} must exist along with all of its
metadata (its grid information, basically) in the scope of the
simulation, it is natural to read the primal grid geometry from it.
Thus an appropriate {\tt iwave\_fields} array for acoustic constant
density modeling is
\begin{verbatim}
FIELD IWaveInfo::iwave_fields[]
= {
  {"csq",    0,    0,  {0, 0, 0}},
  {"uc",     1,    0,  {0, 0, 0}},
  {"up",     1,    0,  {0, 0, 0}},
  {"",       0,    0,  {0, 0, 0}}
};
\end{verbatim}
The last line functions the same way as the traling {\tt NUL} for C
strings, that is, to signal the end of the structure.

Inspection of the pseudo-code above reveals that {\tt up} and {\tt
  csq} need to be available at precisely the same gridpoints, whereas
{\tt uc} must store additional gridpoints around the boundary
(``halo'' or ``ghost'' points) in order that the Laplacian can be
built at the {\tt csq} gridpoints (the ``physical'' grid). So the
memory allocations for {\tt uc} and {\tt up} differ, and the ``swap''
mentioned in the algorithm exchanges only values of the two fields at
physical grid points. The algorithm must be completed with a boundary
loop which updates the non-physical gridpoints of {\tt uc}, for
example with odd reflection implementing a Dirichlet condition.

The design described in the preceding paragraphs is realized in the
IWAVE acoustic constant density package, {\tt
  RSFSRC/trip/iwave/acd}. The standalone executable implementing the
various options provided by IWAVE is also called {\tt acd}. It can be
built as part of a Madagascar top-down build, in which case it shows
up as {\tt RSFROOT/bin/sfacd} and can be referenced as {\tt acd} in
Madagascar {\tt Flow}s, or standalone via invocation of {\tt scons} in
either {\tt RSFSRC/trip} or {\tt RSFSRC/trip/iwave}. In the latter
case, the dependency {\tt RSFSRC/trip/rvl} must be built first. The
standalone build has the virtue of permitting local control of build
environment. The {\tt RSFSRC/trip/admin} directory includes a number
of example configuration scripts for build options - to use, copy one
of these, or create a similar file, as
{\tt config.py} in the root build directory.

The standalone build results in the executable command 
\begin{verbatim}
  RSFSRC/trip/iwave/acd/main/acd.x. 
\end{verbatim}
In the remainder of this paper, I
will refer to this command as {\tt acd.x}. The {\tt SConstruct} file
in the {\tt project} subdirectory of the paper directory is also
configured to use this standalone-built command.

The IWAVE acoustic constant density implementation includes code for
the acoustic simulator and its derivatives (with respect to
velocity-squared) of orders 1 and 2, and
their adjoints, built from a simple numerical kernel (or set
of kernels) of truncation orders in space 2, 4, and 8, and truncation
order 2 in time. My research group has used the Tapenade
\cite[]{TapenadeRef13} automatic differentiation package to produce the
code for derivatives and adjoints. For example, the signature of an
implementation of the $(2, 2k)$ scheme for 3D is
\begin{verbatim}
acd_3d_[2k](float *** uc3, 
            float *** up3, 
            float *** csq3, 
            int * s, 
            int * e,
            ...,
            int * lbc,
            int * rbc);
\end{verbatim}
in which {\tt uc3} is the 3-dimensional array view of the array {\tt
  uc}, and so on; {\tt s} and {\tt e} are the vectors of start and end
indices for the loop over gridpoints; and {\tt ...} stands in for a
list of difference formula coefficients, the the number and value of
which depend on the order ($2k$). The integer arrays {\tt lbc} and
{\tt rbc} flag whether the left and right boundaries of the
computational domain, delimited by {\tt s} and {\tt e}, are external
(physical) boundaries or internal boundaries. In the former case,
phsical boundary conditions must be applied; these are also part of
the code.

Tapenade produces similar code for the first derivative of
this stencil (with respect to the {\tt uc}, {\tt up}, and {\tt csq}
arguments, with signature
\begin{verbatim}
void acd_3d_[2k]_d(float *** uc, 
                   float *** ucd, 
                   float *** up, 
                   float *** upd, 
                   float *** csq,
                   float *** csqd, 
                   int * s, 
                   int * e, 
                   ...,
                   int *lbc,
                   int *rbc);
\end{verbatim}
in which {\tt ucd}, {\tt upd}, and {\tt csqd} are the perturbations of
the arrays without the {\tt d}'s. 

These kernels can be folded into an obvious case list, switched by the
inputs to the timestep interface described above.

Tapenade output is not entirely suitable for immediate use: some minor
cleanup is necessary, and any serious optimizations (vectorization,
for instance) will need to be applied in a tuning phase. However the
code as it comes from the package is correct and reasonably readable,
and can serve as a baseline with which to verify tuned versions.

Definition of a command based on the fields and functions described
above requires one more piece of information: the connection of
fields to external data sources and sinks, intermediated by i/o
keywords. Many choices are possible; one reasonable choice for the 
standalone command option and constant density acoustics ({\tt acd.x})
is:
\begin{verbatim}
IOKEY IWaveInfo::iwave_iokeys[]
= {
  {"csq",    0, true,  true },
  {"data",   1, false, true },
  {"source", 1, true,  false},
  {"movie",  1, false, false},
  {"initc",  1, true,  false},
  {"initp",  2, true,  false},
  {"",       0, false, false}
};
\end{verbatim}
Clearly the velocity (or rather velocity-squared) must be made
available. Two outputs from {\tt uc} are identified, {\tt "data"}
and {\tt "movie"}: while nothing about the specs demands this usage,
the first is intended for trace output, the second for time slices,
as the keywords choices are intended to suggest. Since the precise
mechanism of I/O is inherent in the data unit (file structure, for
instance) rather than the directed by the code, in fact these mnemonic
suggestions could be ignored, and {\tt "data"} used to store a
movie, for example. However it is an intended use case that movies
might be generated at a byproduct of trace generation, so two output
slots are provided. Similarly, several input keywords 
suggest a right-hand side input (time dependent force divergence
traces) ({\tt "source"}) and Cauchy data ({\tt "initc"}, {\tt "initp"}).

Note that the discrete Cauchy data represent pressure at two successive time levels,
whereas the natural Cauchy data for the wave equation would provide
presure and its time derivative. An application accepting this natural
Cauchy data would need to pre-process it into discrete Cauchy data as
indicated above. I have elected to ``un-bundle'' this type of
pre-processing, that is, it is not included in the IWAVE code
itself. Similarly, the natural SEGY representation of the RHS source
traces needs to be pre-processed to code the source positions as
receiver coordinates, as reviewed below.

\subsection{Single Shot Examples}
The examples presented here are built in the {\tt project} subdirectory of the
paper directory, and organized in standard Madagascar
fashion with SConstruct \cite[]{Madagascar}. Details of the build are best
appreciated by reading the {\tt SConstruct} script in {\tt
  ./project}. All use the standalone build of the acoustic constant
density command {\tt acd.x} (in {\tt
  RSFSRC/trip/iwave/acd/main}). This command self-docs: all of the
parameters described below, and others not used in these examples, are
described in the self-doc, which the reader should consult in
conjunction with this discussion.

All of these examples use the simple layered velocity
(-squared) model depicted in Figure \ref{fig:csq-4layer}. 
This data derives from a corresponding velocity model, fetched from
and squared to create a velocity-squared field.

\plot{csq-4layer}{width=15cm}{Four layer deep-water cartoon - quantity
  plotted is velocity squared.}

\noindent \paragraph{Movie from Initial Data.} 
Figure \ref{fig:gauss}
displays a Gaussian initial field, input as the initial potential
field {\tt uc}.  Since  {\tt up} is not input, it remains at its
default value of zero. The resulting IWAVE solution is not convergent
to the solution of any particular Cauchy problem with full convergence
order (2), but produces a reasonable-looking movie. Another (minor)
application would produce a correction to be added to the {\tt up}
field to restore 2nd order convergence.

\plot{gauss}{width=15cm}{Gaussian initial datum}

The data depicted in Figures \ref{fig:csq-4layer} and \ref{fig:gauss}
is input to the simulation, so clearly must exist prior to
simulation. However the output must also exist: IWAVE I/O, both reads
and writes, is driven by the target data structure. Therefore the
movie output file must be constructed before the simulation fills it
with data. The {\tt SConstruct} script contains an invocation of the
{\tt sfmakevel} command which creates a 3D {\tt rsf} file {\tt
  movieinit.rsf}. On completion of the command, this file holds the
movie output.

Perusal of this command reveals some customization of the {\tt rsf}
file format, as compared to its standard use (\cite{Madagascar}). The
duration of the movie determines the duration of the simulation: the
initial simulation time is the time of the initial movie frame, and
similarly for the final time. Thus IWAVE must be able to determine
which axis specified in {\tt movieinit.rsf} is the time axis. Three
additional header word categories, beyond those of the {\tt rsf}
standard, make this feat possible:
\begin{itemize}
\item {\tt dim} = spatial dimension - should be same as spatial
  dimension of the primary static file (keyword {\tt csq} in this
  case).
\item {\tt gdim} = global dimension - of the data array, at least {\tt
    dim}
\item {\tt id1, id2, id3,...}: identification tags of axes 1, 2, 3,...
\end{itemize}
By IWAVE convention, axis with tag = {\tt dim} is the time axis, and axes 0,
1,..., {\tt dim}-1 are the spatial axes. More than {\tt dim} axes are
permitted - they are used to represent other acquisition or modeling
parameters, see section on multi-shot simulation, below.

In this example, the space dimension is 2, so {\tt id3=2} indicates
that the 3rd axis is the time axis.

After propagating 5.12 s and interacting with both the
reflecting (Dirichlet) boundaries and the interfaces in the model, the
potential field becomes that depicted in Figure
\ref{fig:frameinit}. 

\plot{frameinit}{width=15cm}{Acoustic potential field at
  5.12 s, resulting from Gaussian initial data}

Parameters passed to the command {\tt acd.x} included 
\begin{verbatim}
           csq = ../csq_4layer.rsf
         initc = ../init.rsf
         movie = ../movieinit.rsf
\end{verbatim}
Keywords {\tt data} and {\tt source} were ignored. Many other
paramters were required; a brief description of these is included in
the self-doc of the command {\tt acd.x}.

Note that the pathnames refer to the directory level above the working
directory. IWAVE produces various diagnostic output at runtime,
switched by various flags passed as parameters. These outputs, and
possibly other auxiliary outputs of commands built upon IWAVE (eg. the
data residual in an inversion) vary with application and data, so are
inconvenient to specify individually as cleanup targets. Instead, the
SConstruct script creates a working subdirectory and executes (and
dumps its auxiliary output) there. The entire directory is cleaned up
by {\tt scons -c}. So the correct parameter specification for archival
input and output files is one directory level up.

\noindent \paragraph{Movie from Point Source.} 
The pulse in Figure \ref{fig:wavelet} the derivative of a 5 Hz
Gaussian; it is embedded in a space-time field via the {\tt
  iwave/trace/main/towed\_array.x} utility, and used as the RHS in the
wave equation. The resulting field (starting from homogeneous Cauchy
data) at 5.12 s is depicted in Figure \ref{fig:framesrc}.

\plot{wavelet}{width=15cm}{Derivative of 5 Hz Gaussian}

\plot{framesrc}{width=15cm}{Acoustic potential field at
  5.12 s, resulting from Gaussian derivative point source pulse
  located at x=12 km, z = 1.875 km.}

In this case, the parameters passed to {\tt acd.x} (in addition to the
other required numerical parameters) are 
\begin{verbatim}
           csq = ../csq_4layer.rsf
        source = ../wavelet12000.su
         movie = ../movieinit.rsf
\end{verbatim}
The point source data are presented as SEGY traces, rather than as an
RSF data file; the latter would in principle also be possible, but at
the time of this writing RSF trace I/O is not enabled.

\noindent \paragraph{Trace Data from Point Source}
The same point source as in the previous example produces sthe traces
at 6 m depth depicted in Figure \ref{fig:shot12000}. The sampling is
also pure point, that is, does not filter the potential field in any
way. So this trace data could be interpreted as the 2D pressure
traces of a point source with 5 Hz Gaussian pulse, for example.
In this case, the required parameters are
\begin{verbatim}
           csq = ../csq_4layer.rsf
        source = ../wavelet12000.su
          data = ../shot12000.su
\end{verbatim}
As noted before, there is nothing sacred about the string {\tt data} -
any keyword identified in the I/O key struct as output from {\tt uc}
would do just as well. This key is provided for mnemonic convenience.
Note that the file data structure ({\tt shot12000.su}) entirely
determines the  {\em way} in which the data is written - sampling,
source and receiver geometry are all taken from this file.

\plot{shot12000}{width=15cm}{Response of seafloor pressure sensor at
  1.875 km depth, to 400 shots spaced 25 m apart at 6 m depth, source is isotropic point
  radiator, source pulse is Gaussian
  derivative with peak frequency 5 Hz,}

\noindent \paragraph{Born Approximation}
The linearization of the acoustic field with respect to the wave
velocity is the solution $\delta u$ of
\begin{eqnarray}
\frac{\partial^2 u}{\partial t^2} - c^2 \nabla^2 u & = & f,\\
\frac{\partial^2 \delta u}{\partial t^2} - c^2 \nabla^2 \delta u & = &
\frac{2\delta c}{c^3}\frac{\partial^2 u}{\partial t^2},
\end{eqnarray}
\[
u(\bx,0) = u_0(\bx),\,\,\frac{\partial u}{\partial t}(\bx,0) =
v_0(\bx)\,\, \bx \in \Omega,
\]
\[
\delta u(\bx,0) = 0,\,\,\frac{\partial \delta u}{\partial t}(\bx,0) =
0\,\, \bx \in \Omega,
\]
\[
u(\bx,t) = \delta u(\bx,t) = 0, \,\bx \in \partial \Omega.
\]
As explained above, the IWAVE framework provides approximations for
computing the linearization (widely called the ``Born approximation'',
even though this is strictly a misnomer), along with its adjoint and
higher derivatives. 

The parameter key {\tt deriv} flags the computation, or not, of
derivatives. The value assigned is the order of derivative, with
default 0. Each input perturbation (representing quantities such as
$\delta c$ in the linearized system of PDEs, above) is assigned a key
equal to the key for the unperturbed quantity with {\tt \_d1} appended
(for the first derivative - higher derivatives require multiple input
perturbations, keys for which have {\tt \_d2},
{\tt \_d3},... appended). Output keys remain the same as for the reference
computation. 

For the acoustic constant density application, Born approximation
requires reference and perturbation square velocity fields. Figures
\ref{fig:dcsq-4layer} and \ref{fig:csq-4layersm} show perturbation and
reference square velocity fields, respectively, that will generate
Born data roughly corresponding to the preceding example. The required
parameters are
\begin{verbatim}
         deriv = 1
           csq = ../csq_4layer.rsf
        csq_d1 = ../dcsq_4layer.rsf
        source = ../wavelet12000.su
          data = ../born12000.su
\end{verbatim}
The linearized response (Born modeling) corresponding to Figure 
\ref{fig:shot12000} appears as Figure \ref{fig:born12000}.

\plot{dcsq-4layer}{width=15cm}{Velocity-squared perturbation -
  localized oscillations at layer boundaries}
\plot{csq-4layersm}{width=15cm}{Smooth velocity-squared obtained from
  velocity of Figure \ref{fig:csq-4layer} by filtering with a cubic spline window.}
\plot{born12000}{width=15cm}{Linearized response (``Born modeling'') of seafloor pressure
  sensor, due to perturbation (Figure \ref{fig:dcsq-4layer}) about
  smooth background (Figure \ref{fig:csq-4layersm}); other parameters
  as in Figure \ref{fig:shot12000}.}

\noindent \paragraph{Reverse Time Migration}
One version of Reverse Time Migration (RTM) is simply the adjoint of
Born modeling. IWAVE provides adjoint computations for every
derivative mapping (first, second,...) using the {\em optimal
  checkpointing} method of reverse time propagation
\cite[]{Griewank:book,BlanVerSy:95,Plessix:06,Symes:06a-pub}. Other approaches to time reversal can be more efficient in
special cases, especially when the interior dynamics are conservative
(acoustics, elasticity) \cite[]{Dussaud:08,Clapp:09}. However
none are more effective in general, in particular when energy
attenuation is significant part of wave dynamics, as is the case for
all realistic models of seismic wave motion. 

Figure \ref{fig:migr12000} displays the migration of the single
Born ``shot'' gather (really, OBS receiver gather) located at $x_s = 12000$ m from
the left edge of the model. No effort has been made to remove the
low-frequency noise caused by the sea bottom reflection.

\plot{migr12000}{width=15cm}{Reverse-time migration of Born data
  from Figure \ref{fig:born12000}.}

The parameters required for this job are
\begin{verbatim}
         deriv = 1
       adjoint = 1
        nsnaps = 10
           csq = ../csq_4layer.rsf
        csq_b1 = ../migr12000.rsf
        source = ../wavelet12000.su
          data = ../born12000.su
\end{verbatim}

The {\tt adjoint} key flags the adjoint computation. The checkpointing
algorithm requires allocation of workspace for checkpoints (copies of
wavefield Cauchy data, consisting of all dynamic arrays).  The number
of checkpoints allocated is the value for key {\tt nsnaps}. The
appropriate number of checkpoints depends on the number of time
steps. Reasonable numbers to achieve a cost ratio of adjoint to
forward computations of around 5 are
\begin{itemize}
\item up to 1000 time steps: 5 checkpoints
\item up to 5000 time steps: 10 checkpoints
\item up to 10000 time steps: 20 checkpoints
\item up to 20000 time steps: 30 checkpoints
\end{itemize}

\subsection{Interlude: The Internal Grid}

The basic control structure of IWAVE is its {\em internal grid}, which
describes the global state space of IWAVE simulations. This
rectangular grid is logically equivalent to a tuple of axes; each axis
is regularly sampled, hence described by the usual $(n,d,o)$ triple
familiar from RSF. [In common with conventional usage for this
subject, ``axis'' in this discussion will mean ``finite regularly
sampled interval on an axis''.]

Like RSF, the restriction to regular sampling implies some workarounds
for cases in which data sampling is actually not regular - the notable
instance being trace acquisition geometry. Irregular
sampling parameters find a natural home in the attributes of {\tt IWaveSampler}
i/o objects, which encapsulate all of the information required for i/o
of a given type or format. A reference to the internal grid is an key data member of
every {\tt IWaveSampler} instance.

The spatial axes are obvious members of the internal grid, as is the
time axis. The {\tt IWaveSim} constructor creates a version of the
time axis that combines the various time axes of associated data
objects that have them, and resets the time step to one appropriate
for the simulation (returned by the {\tt TIMESTEP} member function of
{\tt IWaveInfo}). Thus for example the source time axis may even
end earlier than the output trace time axis begins; the internal time
axis contains the union of the two, resampled to the simulation time
step.

Other axes represent other aspects of simulation - most important,
other sampled parameters such as source positions that parametrize
individual shots within a simulation. The internal grid allocates
additional axes to record these parameters. For instance, SEGY data is
organized shot coordinates, on a {\em shot axis}. All coordinates are
recorded in the {\tt IWaveSampler} for SEGY data, but only one
additional axis with stride $1$ is introduced to describe the various
shots.

Additional axes may represent internal degrees of freedom available to
the simulation, for instance space- or time-shift simulation \cite[]{geoprosp:2008}. The use of these internal degrees of freedom will be described
in another report.

With many axes interacting, it is essential to provide some method to
determine their roles. Other data handling systems either carry out
this task in a similar way to that described here (eg. DDS,...) or
ignore it (not an option for IWAVE!). The additional information is
arranged as additional keywords in RSF data files, mentioned earlier
in the discussion of movie output:
\begin{itemize}
\item {\tt dim} = spatial dimension of the simulation
\item {\tt gdim} = global dimension = dimension of internal grid
\item {\tt id1, id2, id3,...} = axis identifiers, coded as follows:
\begin{itemize}
\item {\tt 0,...,dim-1}: spatial dimensions corresponding to these
  choices in SEGY coordinates: 0=z, 1=x, 2=y;
\item{\tt dim}: time
\item{\tt dim+1,...,99}: additional axes for various simulation
  parameters (eg. shot index)
\item{\tt 100,...,dim+99}: internal degrees of freedom (extended
  modeling)
\end{itemize}
\end{itemize}
The labeling of spatial axes avoids external data transpose: if the
data for coefficient arrays is organized with $x$ as the fast
variable, for instance ($x$ meaning the coordinate with that name in
the SEGY data standard, for example), then setting {\tt id1=1}
etc. enables correct sampling of traces. The default settings are {\tt
  id1=0, id1=1, id2=2}. [Note that axis keywords are numbered
Fortran-style, whereas axis values are C-style (beginning with
0). This is done to maintain compatibility with RSF header keywords,
which appear to be inherited from SEPlib.]

\subsection{Multi-shot (survey) simulation}

{\tt IWaveSim} loops over any axes beyond the time axis (signified by {\tt
  idxxx=dim} through {\tt idxxx=99}) that {\tt IWaveSampler} objects 
add to the internal grid. In particular, SEGY data file identified as output or
input adds a simulation axis with {\tt idxxx=dim+1} to the internal
grid. The loop over this axis increments when a the keywords {\tt sx},
{\tt sy}, or {\tt sz} change from one trace to the next, signifying a
new shot.

From the user point of view, this means that multi-shot simulation is
automatic: if multiple shots are part of the output data structure,
then all shots will be simulated.

We show several examples that illustrate this data-flow feature of
IWAVE. The examples are identical to those reviewed above for single
shots, except that the additional computation load of multi-shot
simulation suggests the use of parallelism. The parallel features of
IWAVE (parallel shots, parallel subdomains, parallel loops) will be
the subject of a subsequent report. For now, we note that the {\tt
  partask} keyword indicates the number of shots to run in
parallel. The {\tt SConstruct} files for the several multishot
simulations include a line (near the top) to set the variable {\tt
  NP}. If {\tt NP=1}, then the simulations described below are run in
serial  mode. If {\tt NP} is set to a value larger than one, then this value
indicates the number of shots to process in parallel, via a collection
of MPI communicators. Running several shots in parallel requires that
IWAVE be installed with MPI enabled {{\tt IWAVE\_USE\_MPI} defined as a
compiler parameter, see the {\tt README\_INSTALL} file in the top-level
directory. The number of MPI processes assigned (via {\tt mpirun -np}
can be fewer than the number of shots to be simulated - in that case
the simulations run in batches until all shots are completed. Any
unnecessary processes at the terminal stage of the simulation are simply left
idle, so there is no necessary relation between the number of MPI
processes and the number of shots. The {\tt SConstruct} script in the
project directory for this paper uses {\tt mpirun -np NP} to initiate
MPI and assign the number of processes to be used. The follow-on
report will describe the use of IWAVE in a batch environment, for both
parallelization over shots and via domain decomposition.

The next few examples are large enough that completion single-threaded
execution requires perhaps half an hour on a typical (circa 2014) desktop
CPU.  The data displayed were obtained on a typical multicore desktop
machine, using MPI with {\tt NP=6}. These results are precisely the
same as those that are obtained with a single process, but required
less than 4 minutes walltime.

\noindent \paragraph{Simulation}
Recall that output files for IWAVE applications must exist prior to
execution. Therefore, to simulate 12 shots at intervals of 400 m over
the model depicted in Figure \ref{fig:csq-4layer}, the first step is
to create a suitable SEGY data set to hold the output. Therefore the {\tt
  SConstruct} script creates the output file of zero SEGY traces ({\tt
  line8-12km.su}), subsequently filled with samples by IWAVE, all as
part of the same {\tt Flow} command. As note above, the source must
be properly embedded in a space-time field (collection of SEGY traces)
for each shot location. The utility {\tt trace/main/towed\_array.x}
provides a convenient method for combining the position data of a
prototype SEGY trace file with a choice of source array to produce
translations of a source array to correct shot positions. Other
parameters are as in the single-shot case. The result is displayed in
Figure \ref{fig:line8-12km}.

\plot{line8-12km}{width=15cm}{Response of 13 seafloor pressure sensors
  spaced 400 m apart at
  1.875 km depth, to 400 shots spaced 25 m apart at 6 m depth, sources
  are isotropic point
  radiators, source pulse is Gaussian
  derivative with peak frequency 5 Hz. Velocity-squared model depicted
in Figure \ref{fig:csq-4layer}.}

Perusal of the {\tt project/SConstruct} script shows that in the
invocation of {\tt acd.x}, only the filenames have changed. The
dataflow design of IWAVE, in which data objects determine the way in
which they are read/written, implies that the information about
changed source/receiver geometry and data volume does not need to be
explicitly passed to the simulation command.

\noindent \paragraph{Linearized Simulation}
Linearized simulation (Born modeling) works the same way. The data
predicted from the perturbation in Figure \ref{fig:dcsq-4layer} of the smooth
background velocity (squared) in Figure \ref{fig:csq-4layer}, same
source-receiver geometry as in the preceding example, is displayed in
Figure \ref{fig:born8-12km}.

\plot{born8-12km}{width=15cm}{Linearized response of 13 seafloor pressure sensors
  space 400 m apart at
  1.875 km depth, to 400 shots spaced 25 m apart at 6 m depth, sources
  are isotropic point
  radiators, source pulse is Gaussian
  derivative with peak frequency 5 Hz, Background or reference model
  as in Figure \ref{fig:csq-4layersm}, perturbation as in
  Figure \ref{fig:dcsq-4layer}.}

\noindent \paragraph{Adjoint Linearized Simulation}
Adjoint linearized simulation (reverse time migration) of the 12 shot
linearized data (Figure \ref{fig:born8-12km}) produces the image
displayed in Figure \ref{fig:migr8-12km}. 

\plot{migr8-12km}{width=15cm}{Reverse-time migration of Born data
  from Figure \ref{fig:born8-12km}. Reflectors are correctly
  positioned and clearly visible, along with migration artifacts
  characteristic of raw OBS migration, for example a free-surface
  multiple image slightly above 5000 m depth.}

\section{Conclusion}
This paper has described the overall structure of the IWAVE framework,
and illustrated a few of its capabilities. 

The release of IWAVE described in this paper is 2.0. It implements many use
cases not described here:  
\begin{itemize}
\item multipole source representation - essential to simulate the
  directional nature of field source and receiver arrays;
\item plane wave and other extended sources, including randomized;
\item PML absorbing boundary conditions for acoustic constant density
  simulation, following \cite{GrotePML:10};
\item shot record extension of the acoustic constant density model.
  \cite[]{KerSy:94}
\end{itemize}
All of these simulation modes are as accesssible as easily as those
illustrated in the preceding seciton.

Earlier releases (1.x) of IWAVE included implementations of staggered
grid schemes for acoustics and isotropic linear elasticity
\cite[]{moczoetal:06}. See  \cite{FehlerKeliher:11} for an account of
the role played by the IWAVE acoustic staggered grid code as a QC tool
in the SEAM Phase I project. Revival 
of these applications in the IWAVE 2.0 infrastruction is intended
for a future release.

The QC role in the SEAM project heavily influenced the design of 
IWAVE, particularly the requirement that its performance scale well to
very large simulations and large numbers of threads. All versions of
IWAVE have offered parallelism via domain decomposition: SEAM
simulations typically split simulations involving eight fields and
3000 $\times$ 3000 $\times$ 1500 grid points amongst 1000-4000
processes. The user interface specifies the subdivision of the domain
with a few parameters. Another report will detail domain
decomposition, parallelization over simulations (mentioned above), and
multithreaded parallel loop execution aspects of IWAVE, as well as
performance enhancements implemented in the finite difference kernels.

Another ground-up design goal is to provide a simple interface to
inversion software. \cite{Geopros:11} describe the concept behind
the data interchange mechanism: it is file-based, and motivates the
dataflow design mentioned several times already. Since data objects,
represented as files or collections of files, determine their own i/o
modalities, inversion software can simply communicate pathnames to the
IWAVE interface, rather than some more complex data structure. The
current release couples to (and in fact depends on)
the Rice Vector Library (``RVL'') \cite[]{RVLTOMS}, a
framework for linear algebra and optimization.
IWAVE 2.0 includes full waveform inversion, linearized inversion
(``least squares migration''), and shot record extended linearized inversion or
differential semblance optimization. These and other inversion
applications of IWAVE will be discussed in other reports.

\section{Acknowledgements}
IWAVE has been a team effort: the original design of the core
framework is due to Igor Terentyev, and Tanya Vdovina, Dong Sun, Marco
Enriquez, Xin Wang, Yin Huang, Mario Bencomo, Lei Fu, and Muhong Zhou
have each made major contributions.
Development of IWAVE was supported by the SEG Advanced Modeling (SEAM)
project, by the National Science Foundation under awards 0620821 and
0714193, and by the sponsors of The Rice Inversion Project. The IWAVE
project owes a great deal to several open source seismic software
packages (Seismic Un*x, SEPlib, Madagascar), debts which we gratefully
acknowledge. The author wishes to record his special gratitude to
Sergey Fomel, the architect of Madagascar, for his inspiring ideas and
his generous and crucial help in the integration of IWAVE into Madagascar.

\bibliographystyle{seg}
\bibliography{masterref}

